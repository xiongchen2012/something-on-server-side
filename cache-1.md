# 缓存为王

## 什么是缓存

书中引用的维基百科对缓存的定义是：
> 存储在计算机上的一个原始数据复制集，以便于访问

我看到维基百科上缓存的定义是：
> 凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为Cache。  
> https://zh.wikipedia.org/wiki/%E7%BC%93%E5%AD%98

虽然文字上相差较大，但两者综合起来看，缓存可以理解为：  
```
缓存是原始数据的Copy，目的是为了协调和解决两个系统之间速度差异。让快的系统尽可能不用等待慢的系统处理数据。
```

PS：呆湾人对缓存的叫法是：**快取**，个人感觉这个叫法更贴近缓存的本意。

## 为什么用缓存

1. Cache的核心作用是加快系统存取速度，提高系统性能

   我认为任何系统不管你有多么复杂，设计的多么精妙，都遵循[木桶效应](https://baike.baidu.com/item/%E6%9C%A8%E6%A1%B6%E6%95%88%E5%BA%94 "木桶效应") 。对外表现出的性能只取决于最差的一部分。一个复杂的系统中，有的部分处理速度特别快（如内存读写），有的部分处理特别慢（如网络传输），在两者之间设置一个中间层来消弥这种差异，也可以看做在木桶最短的那快板上做了修补。

2. 方便进行系统调优

   在系统的各个层次引入缓存，可以有效的优化整体系统性能。
   
> 缓存为王，对开发人员来说是**性能为王**，对用户来说是**用户体验为王**

## 缓存的特点

1. Source of Truth

   缓存是原始数据的一份Copy，所以它有Source of Truth，即使缓存里的数据丢了，还可以从原始数据中重建缓存。
   
2. 缓存能进行CRUD操作
  
   缓存不是一成不变，缓存中的数据应该可以随时被更新，被删除等。缓存和原始数据之间必定存在固定的算法，可以有效管理缓存和原始数据之间的对应关系。

3. 缓存也可能是持久化的

   缓存不一定都是存在内存中的（断电就没有了），比如也可以存在SSD等高速存储设备中。

## 缓存的分类
  
按照缓存在系统所处的位置不同可以分为：  
- 客户端缓存  
  缓存的内容位于客户端，当缓存中有需要的内容时，不再向服务器去请求。典型的有Web缓存，HybridApp内缓存等

- 网络缓存  
  网络缓存位于客户端和服务端之间，代理客户端和服务端之间的Request和Response。如果缓存中有内容，代理将不再重新向服务端请求内容，直接将缓存内容返回客户端。典型有的Web代理服务器，CDN等

- 服务端缓存  
  缓存内容位于服务端，典型的有Database缓存、平台级的缓存有Ehcache，应用级的有Redis、Memcached等

按照缓存的规模和部署方式可以分为：
- 单机缓存
- 集群缓存

- 分布式缓存

## 关于缓存的一些术语

- Cache Hit | Cache Miss

  系统接收到客户发起的请求，如果请求的数据恰好在缓存中，称为Cache Hit，反之称为Cache Miss(Miss后如果缓存还有空间的话，会将数据更新到缓存中)

- Cache Cost

  Cache Miss后系统从原始数据源取出数据，然后存入缓存，所花费的时间和存储空间称为缓存成本。

- Cache Failure
  
  如果缓存中的某一数据需要更新，就称为该数据的缓存失效

- 更新策略（替代策略）
  
  Cache Miss后有必要将数据加入到缓存，但是在缓存已满的情况下，需要删除一些旧的数据来存放新的数据。哪些数据需要被删除和替代，取决于缓存使用的更新策略。常见的策略有：
  - Least-Recently-Used:替换最近最少被使用的数据（LRU）
  - Least-Frequently-Used：替换最少被使用的数据（LFU）
  - LRU2：把被访问过2次的数据放入缓存，缓存满后使用LRU算法更新（LRU变种）
  - TwoQueue：两个缓存队列，数据先存入1个，再次命中时再放到第2个队列（2Q，也是LRU变种）
  - SIZE：替换占用空间最大的对象
  - LRU Threshold：不缓存超过某个尺寸的对象（LRU的变种）
  - Log(Size)+LRU：替换尺寸最大的对象，尺寸相当时使用LRU
  - Hyper-G：改进版LRU
  - Pitkow/Recker：替换最近最少使用的对象，除非所有对象都是今天被访问过的。如果是这样的，则替换最大的对象。
  - Lowest-Latency-First、Hybrid、Lowest-Relativ-Value(LRV)
  - Adaptive Replacement Cache
  - Most Recently Used：与LRU相反，替换最近最多被使用的对象（MRU）
  - First In First Out：先进先出（FIFO）
  - Random Cache：完全随机替换
  
